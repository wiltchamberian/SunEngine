/*

typedef struct VkPhysicalDeviceRayTracingFeaturesKHR {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           rayTracing;
    VkBool32           rayTracingShaderGroupHandleCaptureReplay;
    VkBool32           rayTracingShaderGroupHandleCaptureReplayMixed;
    VkBool32           rayTracingAccelerationStructureCaptureReplay;
    VkBool32           rayTracingIndirectTraceRays;
    VkBool32           rayTracingIndirectAccelerationStructureBuild;
    VkBool32           rayTracingHostAccelerationStructureCommands;
    VkBool32           rayQuery;
    VkBool32           rayTracingPrimitiveCulling;
} VkPhysicalDeviceRayTracingFeaturesKHR;

/////////////////////// Ray generation shader 射线生成的shader
#version 460 core
#extension GL_EXT_ray_tracing : enable
layout(location = 0) rayPayloadEXT vec4 payload;
layout(binding = 0, set = 0) uniform accelerationStructureEXT acc;
layout(binding = 1, rgba32f) uniform image2D img;
layout(binding = 1, set = 0) uniform rayParams
{
    vec3 rayOrigin;
    vec3 rayDir;
    uint sbtOffset;
    uint sbtStride;
    uint missIndex;
};
void main() {
    traceRayEXT(acc, gl_RayFlagsOpaqueEXT, 0xff, sbtOffset,
                sbtStride, missIndex, rayOrigin, 0.0,
                computeDir(rayDir, gl_LaunchIDEXT, gl_LaunchSizeEXT),
                100.0f, 0 /* payload */);
    imgColor = payload + vec4(blendColor) ;
    imageStore(img, ivec2(gl_LaunchIDEXT), payload);
}

// Closest hit shader
#version 460 core
#extension GL_EXT_ray_tracing : enable
layout(location = 0) rayPayloadInEXT vec4 payload;

void main() {
    payload = vec4(0.0, 1.0, 0.0, 1.0);
}

// Miss shader
#version 460 core
#extension GL_EXT_ray_tracing : enable
layout(location = 0) rayPayloadInEXT vec4 payload;

void main() {
    payload = vec4(0.0, 0.0, 0.0, 0.0);
}

/////射线查询/////////////////
// 可以随便你嵌入到Vertex Shader还是Fragment Shader中。。。
rayQueryEXT rayQuery;
rayQueryInitializeEXT(rayQuery, accelerationStructure,
                      gl_RayFlagsTerminateOnFirstHitEXT,
                      cullMask, origin, tMin, direction, tMax);

while(rayQueryProceedEXT(rayQuery)) {
    if (rayQueryGetIntersectionTypeEXT(rayQuery, false) ==
        gl_RayQueryCandidateIntersectionTriangleEXT)
    {
        ... // Determine if an opaque
        triangle hit occurred
        if (opaqueHit) rayQueryConfirmIntersectionEXT(rayQuery);
    }
    else if (rayQueryGetIntersectionTypeEXT(rayQuery, false) ==
             gl_RayQueryCandidateIntersectionAABBEXT)
    {
        ... // Determine if an opaque hit occurred in an AABB
        if (opaqueHit) rayQueryGenerateIntersectionEXT(rayQuery, ...);
    }
}


if (rayQueryGetIntersectionTypeEXT(rayQuery, true) ==
    gl_RayQueryCommittedIntersectionNoneEXT)
{
    // Not shadow!
} else {
    // Shadow!
}

*/